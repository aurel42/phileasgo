diff --git a/TODO.md b/TODO.md
index 63b809d..6526443 100644
--- a/TODO.md
+++ b/TODO.md
@@ -33,10 +33,12 @@ X regression: restore telemetry loop to 1Hz
 - debug "patient" mode, and rework urgent/patient/deferral logic
 X regression: AP status line no longer visible
 X Flight Stage state machine needs tuning: take-off triggers after landing; take-off only when accelerating, landing only when decelerating?
-- Flight Stage: refine conditions for stages based on previos stages (e.g. hold only after taxi), remember timestamps for flight stages?!
+X Flight Stage: refine conditions for stages based on previous stages (e.g. hold only after taxi), remember timestamps for flight stages?!
 - rich history: clean up templates for clarity; shorter, more precise language, NO examples
 - improve situational/positional awareness of the LLM, describe distance and direction better.
-- the label of the range rings sometimes periodically jumps between two range rings, needs hysteresis? Depends on window size, ofc.
+X the label of the range rings sometimes periodically jumps between two range rings, needs hysteresis? Depends on window size, ofc.
+- in the frontends, order the API cards by fallback order
+- turn trip summary into a logfile
 
 # Announcements:
 - can either fire once per flight (welcome, debrief) or multiple times (border crossing), this is a fixed behavior of the specific announcement
@@ -58,4 +60,12 @@ Phase 3) Migration of screenshot, border, debrief
 # Trip Themes
 
 # Trip Planning
-- can we pre-plan a whole trip? Generate a flight plan?
\ No newline at end of file
+- can we pre-plan a whole trip? Generate a flight plan?
+
+# Visual Trip History
+- collect breadcrumbs and remember POIs and border crossings along the way
+- during debrief, show the route taken on the map with the POIs we encountered, animated like a replay, with the POIs popping up as we approach them
+- with the little plane icon painting the path (a dotted line) behind it, reminding of the Indiana Jones travel animations
+- take-off and landing icons
+- border crossing icons
+- length/speed of animation matching the length of the debrief
diff --git a/cmd/phileasgo/main.go b/cmd/phileasgo/main.go
index 3465e59..105595f 100644
--- a/cmd/phileasgo/main.go
+++ b/cmd/phileasgo/main.go
@@ -12,6 +12,7 @@ import (
 	"time"
 
 	"phileasgo/internal/api"
+	"phileasgo/pkg/announcement"
 	"phileasgo/pkg/audio"
 	"phileasgo/pkg/beacon"
 	"phileasgo/pkg/classifier"
@@ -116,8 +117,20 @@ func run(ctx context.Context, configPath string) error {
 	wdValidator := wikidata.NewValidator(svcs.WikiClient)
 	verifyStartup(ctx, catCfg, wdValidator)
 
+	// Screenshot Watcher (moved before narrator init)
+	var screenWatcher *watcher.Service
+	if appCfg.Narrator.Screenshot.Enabled {
+		var err error
+		screenWatcher, err = watcher.NewService(appCfg.Narrator.Screenshot.Paths)
+		if err != nil {
+			slog.Warn("Failed to initialize screenshot watcher", "error", err)
+		} else {
+			slog.Info("Screenshot watcher started", "paths", appCfg.Narrator.Screenshot.Paths)
+		}
+	}
+
 	// Narrator & TTS
-	narratorSvc, promptMgr, err := initNarrator(ctx, appCfg, svcs, tr, simClient, st, catCfg)
+	narratorSvc, annMgr, promptMgr, err := initNarrator(ctx, appCfg, svcs, tr, simClient, st, catCfg, screenWatcher)
 	if err != nil {
 		return err
 	}
@@ -143,7 +156,7 @@ func run(ctx context.Context, configPath string) error {
 	visCalc := initVisibility(st)
 
 	// Scheduler
-	sched := setupScheduler(appCfg, simClient, st, narratorSvc, promptMgr, wdValidator, svcs, telH, losChecker, visCalc)
+	sched := setupScheduler(appCfg, simClient, st, narratorSvc, annMgr, promptMgr, wdValidator, svcs, telH, losChecker, visCalc)
 	go sched.Start(ctx)
 
 	// Scorer
@@ -242,10 +255,10 @@ func initCoreServices(st store.Store, cfg *config.Config, tr *tracker.Tracker, s
 	}, nil
 }
 
-func initNarrator(ctx context.Context, cfg *config.Config, svcs *CoreServices, tr *tracker.Tracker, simClient sim.Client, st store.Store, catCfg *config.CategoriesConfig) (*narrator.AIService, *prompts.Manager, error) {
+func initNarrator(ctx context.Context, cfg *config.Config, svcs *CoreServices, tr *tracker.Tracker, simClient sim.Client, st store.Store, catCfg *config.CategoriesConfig, screenWatcher *watcher.Service) (*narrator.AIService, *announcement.Manager, *prompts.Manager, error) {
 	llmProv, err := narrator.NewLLMProvider(cfg.LLM, cfg.History.LLM, svcs.ReqClient, tr)
 	if err != nil {
-		return nil, nil, fmt.Errorf("failed to initialize LLM provider: %w", err)
+		return nil, nil, nil, fmt.Errorf("failed to initialize LLM provider: %w", err)
 	}
 
 	// Configure temperature for narration prompts (bell curve distribution)
@@ -256,11 +269,11 @@ func initNarrator(ctx context.Context, cfg *config.Config, svcs *CoreServices, t
 
 	ttsProv, err := narrator.NewTTSProvider(&cfg.TTS, cfg.Narrator.TargetLanguage, tr)
 	if err != nil {
-		return nil, nil, fmt.Errorf("failed to initialize TTS provider: %w", err)
+		return nil, nil, nil, fmt.Errorf("failed to initialize TTS provider: %w", err)
 	}
 	promptMgr, err := prompts.NewManager("configs/prompts")
 	if err != nil {
-		return nil, nil, fmt.Errorf("failed to initialize prompt manager: %w", err)
+		return nil, nil, nil, fmt.Errorf("failed to initialize prompt manager: %w", err)
 	}
 
 	var beaconSvc *beacon.Service
@@ -284,7 +297,21 @@ func initNarrator(ctx context.Context, cfg *config.Config, svcs *CoreServices, t
 		}
 	}
 
-	return narratorSvc, promptMgr, nil
+	// Initialize Announcement Manager (Decoupled)
+	mgr := announcement.NewManager(narratorSvc)
+
+	// Register Announcements
+	mgr.Register(announcement.NewLetsgo(narratorSvc))
+	mgr.Register(announcement.NewBriefing(narratorSvc))
+	mgr.Register(announcement.NewDebriefing(narratorSvc))
+	mgr.Register(announcement.NewBorderCrossing(narratorSvc))
+
+	// Optional Screenshot Announcement
+	if screenWatcher != nil {
+		mgr.Register(announcement.NewScreenshot(narratorSvc, screenWatcher))
+	}
+
+	return narratorSvc, mgr, promptMgr, nil
 }
 
 func verifyStartup(ctx context.Context, catCfg *config.CategoriesConfig, v *wikidata.Validator) {
@@ -352,8 +379,12 @@ func runServer(ctx context.Context, cfg *config.Config, svcs *CoreServices, ns *
 	return runServerLifecycle(ctx, srv, quit)
 }
 
-func setupScheduler(cfg *config.Config, simClient sim.Client, st store.Store, narratorSvc *narrator.AIService, pm *prompts.Manager, v *wikidata.Validator, svcs *CoreServices, apiHandler *api.TelemetryHandler, los *terrain.LOSChecker, vis *visibility.Calculator) *core.Scheduler {
-	sched := core.NewScheduler(cfg, simClient, apiHandler, narratorSvc, svcs.WikiSvc.GeoService())
+func setupScheduler(cfg *config.Config, simClient sim.Client, st store.Store, narratorSvc *narrator.AIService, annMgr *announcement.Manager, pm *prompts.Manager, v *wikidata.Validator, svcs *CoreServices, apiHandler *api.TelemetryHandler, los *terrain.LOSChecker, vis *visibility.Calculator) *core.Scheduler {
+	sched := core.NewScheduler(cfg, simClient, apiHandler, svcs.WikiSvc.GeoService())
+
+	// Register Heartbeaters
+	sched.AddHeartbeater(narratorSvc) // For persistence
+	sched.AddHeartbeater(annMgr)      // For announcements
 	sched.AddJob(core.NewDistanceJob("DistanceSync", 5000, func(c context.Context, t sim.Telemetry) {
 		_ = st.MarkEntitiesSeen(c, map[string][]string{})
 	}))
@@ -374,23 +405,12 @@ func setupScheduler(cfg *config.Config, simClient sim.Client, st store.Store, na
 
 	// Register Debrief Job (implicitly added by NewScheduler via debriefer arg)
 
-	// Watcher for Screenshots
-	var screenWatcher *watcher.Service
-	if cfg.Narrator.Screenshot.Enabled {
-		var err error
-		screenWatcher, err = watcher.NewService(cfg.Narrator.Screenshot.Paths)
-		if err != nil {
-			slog.Warn("Failed to initialize screenshot watcher", "error", err)
-		} else {
-			slog.Info("Screenshot watcher started", "paths", cfg.Narrator.Screenshot.Paths)
-		}
-	}
+	// Register Debrief Job (implicitly added by NewScheduler via debriefer arg)
 
 	// Hook NarrationJob into POI Manager's scoring loop (every 5s) instead of Scheduler
-	narrationJob := core.NewNarrationJob(cfg, narratorSvc, narratorSvc.POIManager(), simClient, st, los, screenWatcher)
+	narrationJob := core.NewNarrationJob(cfg, narratorSvc, narratorSvc.POIManager(), simClient, st, los)
 	svcs.PoiMgr.SetScoringCallback(func(c context.Context, t *sim.Telemetry) {
-		// 1. Check for Screenshots (Polling)
-		narrationJob.CheckScreenshots(c, t)
+		// NarrationJob no longer polls screenshots; announcements do
 
 		// 2. Process Sync Priority Queue (Manual Overrides)
 		if narratorSvc.HasPendingGeneration() {
diff --git a/pkg/announcement/briefing_test.go b/pkg/announcement/briefing_test.go
index 5c61ce0..a59ea2b 100644
--- a/pkg/announcement/briefing_test.go
+++ b/pkg/announcement/briefing_test.go
@@ -18,6 +18,7 @@ type mockDP struct {
 	GetTripSummaryFunc    func() string
 	GetLastTransitionFunc func(stage string) time.Time
 	NewContextFunc        func() map[string]any
+	GetBorderConfigFunc   func() (bool, time.Duration, time.Duration)
 }
 
 func (m *mockDP) GetPOIsNear(lat, lon, radius float64) []*model.POI {
@@ -54,6 +55,12 @@ func (m *mockDP) NewContext() map[string]any {
 	}
 	return nil
 }
+func (m *mockDP) GetBorderConfig() (bool, time.Duration, time.Duration) {
+	if m.GetBorderConfigFunc != nil {
+		return m.GetBorderConfigFunc()
+	}
+	return true, 0, 0
+}
 
 func TestBriefing_Triggers(t *testing.T) {
 	dp := &mockDP{
diff --git a/pkg/announcement/manager.go b/pkg/announcement/manager.go
index 6c8108e..db40199 100644
--- a/pkg/announcement/manager.go
+++ b/pkg/announcement/manager.go
@@ -35,6 +35,11 @@ func (m *Manager) Register(a Item) {
 	m.registry[a.ID()] = a
 }
 
+// Heartbeat implements the core.Heartbeater interface.
+func (m *Manager) Heartbeat(ctx context.Context, t *sim.Telemetry) {
+	m.Tick(ctx, t)
+}
+
 // Tick evaluates all registered announcements against current telemetry.
 func (m *Manager) Tick(ctx context.Context, t *sim.Telemetry) {
 	m.mu.Lock()
@@ -79,8 +84,21 @@ func (m *Manager) Tick(ctx context.Context, t *sim.Telemetry) {
 		case StatusTriggered:
 			if !a.IsRepeatable() {
 				a.SetStatus(StatusDone)
+				continue
+			}
+			// Repeatable announcements: allow re-triggering based on their own conditions.
+			if a.ShouldGenerate(t) {
+				slog.Info("Announcement: Re-triggering generation", "id", id)
+				a.SetStatus(StatusGenerating)
+				toGenerate = append(toGenerate, a)
+			}
+
+		case StatusMissed:
+			if a.IsRepeatable() {
+				// Repeatable announcements should go back to Idle if they were missed,
+				// so they can try again in the next cycle.
+				a.SetStatus(StatusIdle)
 			}
-			// Waiting for reset
 		}
 	}
 	m.mu.Unlock()
diff --git a/pkg/announcement/types.go b/pkg/announcement/types.go
index 93eb720..9ccbf50 100644
--- a/pkg/announcement/types.go
+++ b/pkg/announcement/types.go
@@ -63,4 +63,7 @@ type DataProvider interface {
 	// Prompt Data Assembly
 	AssemblePOI(ctx context.Context, p *model.POI, t *sim.Telemetry, strategy string) prompt.Data
 	AssembleGeneric(ctx context.Context, t *sim.Telemetry) prompt.Data
+
+	// Border Config
+	GetBorderConfig() (enabled bool, cooldownAny, cooldownRepeat time.Duration)
 }
diff --git a/pkg/core/border_job.go b/pkg/core/border_job.go
deleted file mode 100644
index 6b332df..0000000
--- a/pkg/core/border_job.go
+++ /dev/null
@@ -1,138 +0,0 @@
-package core
-
-import (
-	"context"
-	"fmt"
-	"log/slog"
-	"time"
-
-	"phileasgo/pkg/config"
-	"phileasgo/pkg/model"
-	"phileasgo/pkg/sim"
-)
-
-// BorderJob checks for border crossings (country/region change) every 15s.
-type BorderJob struct {
-	BaseJob
-	narrator             Borderrer
-	geo                  LocationProvider
-	cfg                  *config.Config
-	lastLocation         model.LocationInfo
-	cooldown             time.Duration
-	lastCheck            time.Time
-	lastAnnouncementTime time.Time
-	repeatCooldowns      map[string]time.Time // Key: "from->to", Value: Last trigger time
-}
-
-// NewBorderJob creates a new BorderJob.
-func NewBorderJob(cfg *config.Config, n Borderrer, g LocationProvider) *BorderJob {
-	return &BorderJob{
-		BaseJob:         NewBaseJob("BorderJob"),
-		narrator:        n,
-		geo:             g,
-		cfg:             cfg,
-		cooldown:        15 * time.Second,
-		repeatCooldowns: make(map[string]time.Time),
-	}
-}
-
-func (j *BorderJob) ShouldFire(t *sim.Telemetry) bool {
-	// Periodic check every 15s
-	return time.Since(j.lastCheck) >= j.cooldown
-}
-
-func (j *BorderJob) Run(ctx context.Context, t *sim.Telemetry) {
-	if !j.TryLock() {
-		return
-	}
-	defer j.Unlock()
-
-	j.lastCheck = time.Now()
-
-	// 1. Get current location
-	curr := j.geo.GetLocation(t.Latitude, t.Longitude)
-
-	// Refinement: skip announcements for intermediary maritime zones (EEZ/Territorial)
-	// We do not treat entering these zones as a "border crossing" themselves, and we
-	// don't update lastLocation to ensure we trigger correctly when finally hitting
-	// Land or International Waters.
-	if curr.Zone == "territorial" || curr.Zone == "eez" {
-		return
-	}
-
-	// Detect Change
-	if j.lastLocation.CountryCode == "" {
-		// Initial setup, no change detected
-		slog.Debug("BorderJob: Initialized location", "country", curr.CountryCode, "region", curr.Admin1Name)
-		j.lastLocation = curr
-		return
-	}
-
-	// Check for Country Change
-	if curr.CountryCode != j.lastLocation.CountryCode {
-		j.trigger(ctx, j.lastLocation.CountryCode, curr.CountryCode, t)
-		j.lastLocation = curr
-		return
-	}
-
-	// Check for State/Region Change (Admin1)
-	if curr.Admin1Name != j.lastLocation.Admin1Name {
-		from := j.lastLocation.Admin1Name
-		to := curr.Admin1Name
-
-		// Suppress region transit if either side has no city nearby OR if names are blank.
-		// This avoids noise when moving between "Unknown" regions in wilderness.
-		if curr.CityName == "" || j.lastLocation.CityName == "" || to == "" || from == "" {
-			slog.Debug("BorderJob: Region change suppressed (wilderness/no city)", "from", from, "to", to)
-			j.lastLocation = curr
-			return
-		}
-
-		j.trigger(ctx, from, to, t)
-		j.lastLocation = curr
-		return
-	}
-
-	j.lastLocation = curr
-}
-
-func (j *BorderJob) trigger(ctx context.Context, from, to string, t *sim.Telemetry) {
-	if from == "XZ" {
-		from = "International Waters"
-	}
-	if to == "XZ" {
-		to = "International Waters"
-	}
-
-	// 1. Check Global Cooldown
-	cooldownAny := time.Duration(j.cfg.Narrator.Border.CooldownAny)
-	if time.Since(j.lastAnnouncementTime) < cooldownAny {
-		slog.Debug("BorderJob: Global cooldown active, suppressing announcement", "from", from, "to", to, "remain", cooldownAny-time.Since(j.lastAnnouncementTime))
-		return
-	}
-
-	// 2. Check Repeat Cooldown
-	pairKey := fmt.Sprintf("%s->%s", from, to)
-	cooldownRepeat := time.Duration(j.cfg.Narrator.Border.CooldownRepeat)
-	if lastRepeat, ok := j.repeatCooldowns[pairKey]; ok {
-		if time.Since(lastRepeat) < cooldownRepeat {
-			slog.Debug("BorderJob: Repeat cooldown active for pair, suppressing announcement", "pair", pairKey, "remain", cooldownRepeat-time.Since(lastRepeat))
-			return
-		}
-	}
-
-	slog.Info("BorderJob: Border crossing detected!", "from", from, "to", to, "lat", t.Latitude, "lon", t.Longitude)
-	if j.narrator.PlayBorder(ctx, from, to, t) {
-		j.lastAnnouncementTime = time.Now()
-		j.repeatCooldowns[pairKey] = time.Now()
-	}
-}
-
-// SessionResettable implementation
-func (j *BorderJob) ResetSession(ctx context.Context) {
-	j.lastLocation = model.LocationInfo{}
-	j.lastCheck = time.Time{}
-	j.lastAnnouncementTime = time.Time{}
-	j.repeatCooldowns = make(map[string]time.Time)
-	slog.Debug("BorderJob: Session reset")
-}
diff --git a/pkg/core/border_job_test.go b/pkg/core/border_job_test.go
deleted file mode 100644
index 16f5cdd..0000000
--- a/pkg/core/border_job_test.go
+++ /dev/null
@@ -1,317 +0,0 @@
-package core
-
-import (
-	"context"
-	"phileasgo/pkg/config"
-	"phileasgo/pkg/model"
-	"phileasgo/pkg/sim"
-	"testing"
-	"time"
-)
-
-type mockBorderNarrator struct {
-	lastFrom string
-	lastTo   string
-	calls    int
-}
-
-func (m *mockBorderNarrator) PlayBorder(ctx context.Context, from, to string, tel *sim.Telemetry) bool {
-	m.lastFrom = from
-	m.lastTo = to
-	m.calls++
-	return true
-}
-
-func (m *mockBorderNarrator) Heartbeat(ctx context.Context, tel *sim.Telemetry) {
-	// no-op
-}
-
-func (m *mockBorderNarrator) ReorderFeatures(lat, lon float64) {
-	// no-op
-}
-
-type mockBorderGeo struct {
-	loc model.LocationInfo
-}
-
-func (m *mockBorderGeo) GetLocation(lat, lon float64) model.LocationInfo {
-	return m.loc
-}
-
-func (m *mockBorderGeo) ReorderFeatures(lat, lon float64) {
-	// no-op
-}
-
-func TestBorderJob_InternationalWatersTranslation(t *testing.T) {
-	narrator := &mockBorderNarrator{}
-	geo := &mockBorderGeo{}
-	job := NewBorderJob(config.DefaultConfig(), narrator, geo)
-
-	// 1. Land to Sea
-	job.lastLocation = model.LocationInfo{CountryCode: "FR", CityName: "Paris"}
-	geo.loc = model.LocationInfo{CountryCode: "XZ", CityName: "International Waters"}
-
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.lastFrom != "FR" {
-		t.Errorf("Expected from 'FR', got '%s'", narrator.lastFrom)
-	}
-	if narrator.lastTo != "International Waters" {
-		t.Errorf("Expected to 'International Waters', got '%s'", narrator.lastTo)
-	}
-
-	// 2. Sea to Land
-	job.lastAnnouncementTime = time.Time{}
-	job.lastLocation = model.LocationInfo{CountryCode: "XZ", CityName: "International Waters"}
-	geo.loc = model.LocationInfo{CountryCode: "UK", CityName: "London"}
-
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.lastFrom != "International Waters" {
-		t.Errorf("Expected from 'International Waters', got '%s'", narrator.lastFrom)
-	}
-	if narrator.lastTo != "UK" {
-		t.Errorf("Expected to 'UK', got '%s'", narrator.lastTo)
-	}
-}
-
-func TestBorderJob_Admin1Change(t *testing.T) {
-	narrator := &mockBorderNarrator{}
-	geo := &mockBorderGeo{}
-	job := NewBorderJob(config.DefaultConfig(), narrator, geo)
-
-	// 1. Same Country, Different State
-	job.lastLocation = model.LocationInfo{CountryCode: "US", Admin1Name: "California", CityName: "SF"}
-	geo.loc = model.LocationInfo{CountryCode: "US", Admin1Name: "Nevada", CityName: "Reno"}
-
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.lastFrom != "California" {
-		t.Errorf("Expected from 'California', got '%s'", narrator.lastFrom)
-	}
-	if narrator.lastTo != "Nevada" {
-		t.Errorf("Expected to 'Nevada', got '%s'", narrator.lastTo)
-	}
-}
-
-func TestBorderJob_Concurrency(t *testing.T) {
-	narrator := &mockBorderNarrator{}
-	geo := &mockBorderGeo{}
-	job := NewBorderJob(config.DefaultConfig(), narrator, geo)
-
-	// Lock the job manually
-	if !job.TryLock() {
-		t.Fatal("Failed to lock job")
-	}
-
-	// Try running
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.calls != 0 {
-		t.Error("Job should not have run while locked")
-	}
-
-	job.Unlock()
-
-	// Now it should run
-	job.lastLocation = model.LocationInfo{CountryCode: "A", CityName: "A"}
-	geo.loc = model.LocationInfo{CountryCode: "B", CityName: "B"}
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.calls != 1 {
-		t.Errorf("Expected 1 call after unlock, got %d", narrator.calls)
-	}
-}
-
-func TestBorderJob_BootstrapWithoutCity(t *testing.T) {
-	narrator := &mockBorderNarrator{}
-	geo := &mockBorderGeo{}
-	job := NewBorderJob(config.DefaultConfig(), narrator, geo)
-
-	// 1. Initial location has NO city, but YES country/state
-	geo.loc = model.LocationInfo{CountryCode: "DE", Admin1Name: "Bavaria", CityName: ""}
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.calls != 0 {
-		t.Fatal("Should not trigger on first run")
-	}
-	if job.lastLocation.CountryCode != "DE" {
-		t.Fatal("Initial location should be stored")
-	}
-
-	// 2. Move to different state STILL with no city -> SHOULD BE SUPPRESSED NOW
-	geo.loc = model.LocationInfo{CountryCode: "DE", Admin1Name: "Hesse", CityName: ""}
-	job.Run(context.Background(), &sim.Telemetry{})
-	if narrator.calls != 0 {
-		t.Errorf("Expected 0 calls when state changed without city. Got %d", narrator.calls)
-	}
-
-	// 3. Move to different state WITH a city -> Still suppressed because origin was wilderness
-	geo.loc = model.LocationInfo{CountryCode: "DE", Admin1Name: "Lower Saxony", CityName: "Hannover"}
-	job.Run(context.Background(), &sim.Telemetry{})
-	if narrator.calls != 0 {
-		t.Errorf("Expected 0 calls when entering from wilderness, even with city. Got %d", narrator.calls)
-	}
-
-	// 4. Move from city to city -> SHOULD TRIGGER
-	job.lastAnnouncementTime = time.Time{} // Clear cooldown
-	job.lastLocation = model.LocationInfo{CountryCode: "DE", Admin1Name: "Lower Saxony", CityName: "Hannover"}
-	geo.loc = model.LocationInfo{CountryCode: "DE", Admin1Name: "Hamburg", CityName: "Hamburg"}
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.calls != 1 {
-		t.Errorf("Expected 1 call when moving between cities, got %d", narrator.calls)
-	}
-}
-
-func TestBorderJob_EmptyToNamedState(t *testing.T) {
-	narrator := &mockBorderNarrator{}
-	geo := &mockBorderGeo{}
-	job := NewBorderJob(config.DefaultConfig(), narrator, geo)
-
-	// 1. Initial location in a country where Admin1 is unknown/empty (e.g. crossing from waters)
-	geo.loc = model.LocationInfo{CountryCode: "XZ", Admin1Name: "", CityName: ""}
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	// 2. Cross into a named state
-	geo.loc = model.LocationInfo{CountryCode: "US", Admin1Name: "New York", CityName: "NYC"}
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.calls != 1 {
-		t.Fatalf("Expected 1 call (country change), got %d", narrator.calls)
-	}
-	if narrator.lastTo != "US" {
-		t.Errorf("Expected to 'US', got '%s'", narrator.lastTo)
-	}
-
-	// 3. Cross into a named state in same country (if prior was unknown/no city) -> SHOULD BE SUPPRESSED
-	job.lastAnnouncementTime = time.Time{}
-	job.lastLocation = model.LocationInfo{CountryCode: "US", Admin1Name: "", CityName: ""}
-	geo.loc = model.LocationInfo{CountryCode: "US", Admin1Name: "New Jersey", CityName: "Trenton"}
-	job.Run(context.Background(), &sim.Telemetry{})
-
-	if narrator.calls != 1 {
-		t.Errorf("Expected no 2nd call (suppressed due to wilderness origin), got %d", narrator.calls)
-	}
-}
-
-func TestBorderJob_Cooldowns(t *testing.T) {
-	cfg := config.DefaultConfig()
-	cfg.Narrator.Border.CooldownAny = config.Duration(1 * time.Minute)
-	cfg.Narrator.Border.CooldownRepeat = config.Duration(5 * time.Minute)
-
-	narrator := &mockBorderNarrator{}
-	geo := &mockBorderGeo{}
-	job := NewBorderJob(cfg, narrator, geo)
-
-	ctx := context.Background()
-	tel := &sim.Telemetry{}
-
-	// 1. First crossing (Global)
-	job.lastLocation = model.LocationInfo{CountryCode: "A"}
-	geo.loc = model.LocationInfo{CountryCode: "B"}
-	job.Run(ctx, tel)
-	if narrator.calls != 1 {
-		t.Fatalf("Expected 1st call, got %d", narrator.calls)
-	}
-
-	// 2. Immediate crossing elsewhere (Should be suppressed by GLOBAL cooldown)
-	job.lastLocation = geo.loc
-	geo.loc = model.LocationInfo{CountryCode: "C"}
-	job.Run(ctx, tel)
-	if narrator.calls != 1 {
-		t.Errorf("Expected 1 call (suppressed by global), got %d", narrator.calls)
-	}
-
-	// 3. Wait for global cooldown, then cross back to A (REPETITIVE crossing)
-	job.lastAnnouncementTime = time.Now().Add(-2 * time.Minute)
-	job.lastLocation = geo.loc
-	geo.loc = model.LocationInfo{CountryCode: "B"}
-	job.Run(ctx, tel)
-	if narrator.calls != 2 {
-		t.Errorf("Expected 2 calls (global passed), got %d", narrator.calls)
-	}
-
-	// 4. Repeated crossing B -> C (Should be suppressed by REPEAT cooldown)
-	job.lastAnnouncementTime = time.Now().Add(-10 * time.Minute) // Bypass global
-	job.lastLocation = geo.loc
-	geo.loc = model.LocationInfo{CountryCode: "C"}
-	// Let's make it actually trigger first.
-	job.lastAnnouncementTime = time.Now().Add(-10 * time.Minute) // Long ago
-	job.repeatCooldowns = make(map[string]time.Time)             // Clear
-	job.lastLocation = model.LocationInfo{CountryCode: "A"}
-	geo.loc = model.LocationInfo{CountryCode: "B"}
-	job.Run(ctx, tel) // Call 3: A -> B
-	if narrator.calls != 3 {
-		t.Errorf("Expected 3 calls, got %d", narrator.calls)
-	}
-
-	// 5. Cross back B -> A
-	job.lastAnnouncementTime = time.Now().Add(-10 * time.Minute)
-	job.lastLocation = geo.loc
-	geo.loc = model.LocationInfo{CountryCode: "A"}
-	job.Run(ctx, tel) // Call 4: B -> A
-	if narrator.calls != 4 {
-		t.Errorf("Expected 4 calls, got %d", narrator.calls)
-	}
-
-	// 6. Immediate repeat A -> B (Suppressed by REPEAT cooldown even if global passes)
-	job.lastAnnouncementTime = time.Now().Add(-10 * time.Minute)
-	job.lastLocation = geo.loc
-	geo.loc = model.LocationInfo{CountryCode: "B"}
-	job.Run(ctx, tel)
-	if narrator.calls != 4 {
-		t.Errorf("Expected 4 calls (suppressed by repeat), got %d", narrator.calls)
-	}
-}
-
-func TestBorderJob_MaritimeRestrictions(t *testing.T) {
-	narrator := &mockBorderNarrator{}
-	geo := &mockBorderGeo{}
-	job := NewBorderJob(config.DefaultConfig(), narrator, geo)
-
-	// 1. Land (FR) to Territorial (FR) -> Should be ignored
-	job.lastLocation = model.LocationInfo{CountryCode: "FR", Admin1Name: "Normandy", Zone: "land"}
-	geo.loc = model.LocationInfo{CountryCode: "FR", Admin1Name: "", Zone: "territorial"}
-	job.Run(context.Background(), &sim.Telemetry{})
-	if narrator.calls != 0 {
-		t.Errorf("Expected 0 calls for territorial waters, got %d", narrator.calls)
-	}
-	if job.lastLocation.Admin1Name != "Normandy" {
-		t.Errorf("Expected lastLocation to remain Normandy, got %s", job.lastLocation.Admin1Name)
-	}
-
-	// 2. Territorial (FR) to International -> Should trigger FR -> International
-	geo.loc = model.LocationInfo{CountryCode: "XZ", Admin1Name: "", Zone: "international"}
-	job.Run(context.Background(), &sim.Telemetry{})
-	if narrator.calls != 1 {
-		t.Fatalf("Expected 1 call when entering international waters, got %d", narrator.calls)
-	}
-	if narrator.lastFrom != "FR" {
-		t.Errorf("Expected from 'FR', got '%s'", narrator.lastFrom)
-	}
-	if narrator.lastTo != "International Waters" {
-		t.Errorf("Expected to 'International Waters', got '%s'", narrator.lastTo)
-	}
-
-	// 3. International to EEZ (UK) -> Should be ignored
-	job.lastAnnouncementTime = time.Time{} // reset cooldown
-	geo.loc = model.LocationInfo{CountryCode: "UK", Admin1Name: "", Zone: "eez"}
-	job.Run(context.Background(), &sim.Telemetry{})
-	if narrator.calls != 1 {
-		t.Errorf("Expected no new calls when entering EEZ, got %d", narrator.calls)
-	}
-
-	// 4. EEZ (UK) to Land (UK) -> Should trigger International -> UK
-	geo.loc = model.LocationInfo{CountryCode: "UK", Admin1Name: "Kent", Zone: "land"}
-	job.Run(context.Background(), &sim.Telemetry{})
-	if narrator.calls != 2 {
-		t.Errorf("Expected 2nd call when hitting land, got %d", narrator.calls)
-	}
-	if narrator.lastFrom != "International Waters" {
-		t.Errorf("Expected from 'International Waters', got '%s'", narrator.lastFrom)
-	}
-	if narrator.lastTo != "UK" {
-		t.Errorf("Expected to 'UK', got '%s'", narrator.lastTo)
-	}
-}
diff --git a/pkg/core/interfaces.go b/pkg/core/interfaces.go
index 6881145..40e1c28 100644
--- a/pkg/core/interfaces.go
+++ b/pkg/core/interfaces.go
@@ -13,9 +13,8 @@ type SessionResettable interface {
 	ResetSession(ctx context.Context)
 }
 
-// Borderrer interface for triggering border announcements.
-type Borderrer interface {
-	PlayBorder(ctx context.Context, from, to string, tel *sim.Telemetry) bool
+// Heartbeater interface for driving periodic tasks like announcements.
+type Heartbeater interface {
 	Heartbeat(ctx context.Context, tel *sim.Telemetry)
 }
 
diff --git a/pkg/core/narration_frequency_test.go b/pkg/core/narration_frequency_test.go
index ec2a3c9..1b76dea 100644
--- a/pkg/core/narration_frequency_test.go
+++ b/pkg/core/narration_frequency_test.go
@@ -177,7 +177,7 @@ func TestNarrationJob_Frequency_Strategies(t *testing.T) {
 			simC := &mockJobSimClient{state: sim.StateActive}
 
 			// Note: We pass nil for store, so it falls back to cfg.Frequency
-			job := NewNarrationJob(cfg, mockN, pm, simC, nil, nil, nil)
+			job := NewNarrationJob(cfg, mockN, pm, simC, nil, nil)
 
 			// Force cooldown ready for non-playing case
 			job.lastTime = time.Now().Add(-10 * time.Minute)
diff --git a/pkg/core/narration_job.go b/pkg/core/narration_job.go
index af64dab..8a22337 100644
--- a/pkg/core/narration_job.go
+++ b/pkg/core/narration_job.go
@@ -15,7 +15,6 @@ import (
 	"phileasgo/pkg/sim"
 	"phileasgo/pkg/store"
 	"phileasgo/pkg/terrain"
-	"phileasgo/pkg/watcher"
 )
 
 // POIProvider matches the GetBestCandidate method used by NarrationJob.
@@ -33,7 +32,6 @@ type NarrationJob struct {
 	sim        sim.Client
 	store      store.Store
 	losChecker *terrain.LOSChecker
-	watcher    *watcher.Service
 	lastTime   time.Time
 
 	wasBusy          bool
@@ -44,7 +42,7 @@ type NarrationJob struct {
 	lastAGL float64 // Last known AGL for visibility boost check
 }
 
-func NewNarrationJob(cfg *config.Config, n narrator.Service, pm POIProvider, simC sim.Client, st store.Store, los *terrain.LOSChecker, w *watcher.Service) *NarrationJob {
+func NewNarrationJob(cfg *config.Config, n narrator.Service, pm POIProvider, simC sim.Client, st store.Store, los *terrain.LOSChecker) *NarrationJob {
 	j := &NarrationJob{
 		BaseJob:    NewBaseJob("Narration"),
 		cfg:        cfg,
@@ -53,7 +51,6 @@ func NewNarrationJob(cfg *config.Config, n narrator.Service, pm POIProvider, sim
 		sim:        simC,
 		store:      st,
 		losChecker: los,
-		watcher:    w,
 		lastTime:   time.Now(),
 	}
 
@@ -138,16 +135,6 @@ func (j *NarrationJob) CanPrepareEssay(t *sim.Telemetry) bool {
 	return j.checkEssayEligible(t)
 }
 
-// CheckScreenshots polls the watcher for new screenshots and triggers playback.
-func (j *NarrationJob) CheckScreenshots(ctx context.Context, t *sim.Telemetry) {
-	if j.watcher != nil && j.cfg.Narrator.Screenshot.Enabled {
-		if path, ok := j.watcher.CheckNew(); ok {
-			slog.Info("NarrationJob: New screenshot detected", "path", path)
-			j.narrator.PlayImage(ctx, path, t)
-		}
-	}
-}
-
 // PreparePOI triggers the finding and playing of a POI.
 // Returns true if a POI was successfully found and triggered (or pipelined).
 func (j *NarrationJob) PreparePOI(ctx context.Context, t *sim.Telemetry) bool {
diff --git a/pkg/core/narration_job_test.go b/pkg/core/narration_job_test.go
index 54b37ab..3d04f64 100644
--- a/pkg/core/narration_job_test.go
+++ b/pkg/core/narration_job_test.go
@@ -2,14 +2,11 @@ package core
 
 import (
 	"context"
-	"os"
-	"path/filepath"
 	"phileasgo/pkg/config"
 	"phileasgo/pkg/model"
 	"phileasgo/pkg/narrator"
 	"phileasgo/pkg/sim"
 	"phileasgo/pkg/store"
-	"phileasgo/pkg/watcher"
 	"testing"
 	"time"
 )
@@ -894,57 +891,3 @@ func TestNarrationJob_StartAirborne_NoDelay(t *testing.T) {
 		t.Error("Started airborne but CanPreparePOI returned false (Grace period incorrectly applied?)")
 	}
 }
-
-func TestNarrationJob_ScreenshotDetection(t *testing.T) {
-	// Create temp dir for watcher
-	tmpDir := t.TempDir()
-
-	cfg := config.DefaultConfig()
-	cfg.Narrator.AutoNarrate = true
-	cfg.Narrator.Screenshot.Enabled = true
-	cfg.Narrator.Essay.Enabled = false // Prevent essay fallback from firing
-
-	mockN := &mockNarratorService{}
-	pm := &mockPOIManager{best: nil, lat: 48.0, lon: -123.0} // Valid location for consistency check
-	simC := &mockJobSimClient{state: sim.StateActive}
-
-	// Create real watcher pointing to temp dir
-	w, err := watcher.NewService([]string{tmpDir})
-	if err != nil {
-		t.Fatalf("Failed to create watcher: %v", err)
-	}
-	// We don't start the watcher loop, we just use CheckNew manually via NarrationJob logic
-
-	job := NewNarrationJob(cfg, mockN, pm, simC, nil, nil, w)
-
-	job.lastTime = time.Time{} // Force ready
-
-	tel := &sim.Telemetry{
-		AltitudeAGL: 3000,
-		Latitude:    48.0,
-		Longitude:   -123.0,
-	}
-
-	// 1. Initial State: No screenshot
-	// CheckScreenshots should NOT trigger PlayImage
-	job.CheckScreenshots(context.Background(), tel)
-	if mockN.playImageCalled {
-		t.Error("PlayImage call unexpectedly")
-	}
-
-	// 2. Create Dummy Screenshot
-	time.Sleep(1100 * time.Millisecond) // Ensure FS modtime > watcher creation time (Windows resolution safety)
-	imagePath := filepath.Join(tmpDir, "screen_test.png")
-	if err := os.WriteFile(imagePath, []byte("fake png"), 0644); err != nil {
-		t.Fatalf("Failed to write temp file: %v", err)
-	}
-
-	// 3. CheckScreenshots should found it and Play
-	// Note: CheckNew depends on file mod time vs lastChecked.
-	// Since watcher was created BEFORE file write, modTime > lastChecked.
-	job.CheckScreenshots(context.Background(), tel)
-
-	if !mockN.playImageCalled {
-		t.Error("PlayImage was NOT called after detecting screenshot")
-	}
-}
diff --git a/pkg/core/scheduler.go b/pkg/core/scheduler.go
index 0396231..6166ca0 100644
--- a/pkg/core/scheduler.go
+++ b/pkg/core/scheduler.go
@@ -24,31 +24,29 @@ type Scheduler struct {
 	jobs             []Job
 	resettables      []SessionResettable
 	lastTickPos      geo.Point
-	narrator         Borderrer // Renamed from debriefer for generalized use
+	heartbeaters     []Heartbeater
 	locationProvider LocationProvider
 }
 
 // NewScheduler creates a new Scheduler.
-func NewScheduler(cfg *config.Config, simClient sim.Client, sink TelemetrySink, n Borderrer, g LocationProvider) *Scheduler {
+func NewScheduler(cfg *config.Config, simClient sim.Client, sink TelemetrySink, g LocationProvider) *Scheduler {
 	s := &Scheduler{
 		cfg:              cfg,
 		sim:              simClient,
 		sink:             sink,
 		jobs:             []Job{},
 		resettables:      []SessionResettable{},
-		narrator:         n,
+		heartbeaters:     []Heartbeater{},
 		locationProvider: g,
 	}
 
-	// Register Core Jobs
-	// Border Job
-	borderJob := NewBorderJob(cfg, n, g)
-	s.AddJob(borderJob)
-	s.AddResettable(borderJob)
-
 	return s
 }
 
+func (s *Scheduler) AddHeartbeater(h Heartbeater) {
+	s.heartbeaters = append(s.heartbeaters, h)
+}
+
 // AddResettable registers a component to be reset on session change (teleport).
 func (s *Scheduler) AddResettable(r SessionResettable) {
 	s.resettables = append(s.resettables, r)
@@ -111,9 +109,9 @@ func (s *Scheduler) tick(ctx context.Context) {
 		s.sink.Update(&tel)
 	}
 
-	// 2.2 Announcements Heartbeat
-	if s.narrator != nil {
-		s.narrator.Heartbeat(ctx, &tel)
+	// 2.2 Heartbeats
+	for _, h := range s.heartbeaters {
+		h.Heartbeat(ctx, &tel)
 	}
 
 	// 2.5 Teleport Detection
diff --git a/pkg/core/scheduler_teleport_test.go b/pkg/core/scheduler_teleport_test.go
index 6b7610e..fad50f7 100644
--- a/pkg/core/scheduler_teleport_test.go
+++ b/pkg/core/scheduler_teleport_test.go
@@ -43,7 +43,7 @@ func TestScheduler_TeleportDetection(t *testing.T) {
 	// It has SetTelemetry helper
 	mockSim := &mockSimClient{}
 
-	sched := NewScheduler(cfg, mockSim, nil, &mockTeleportNarrator{}, &mockTeleportGeoProvider{})
+	sched := NewScheduler(cfg, mockSim, nil, &mockTeleportGeoProvider{})
 
 	mr1 := &mockResettable{}
 	mr2 := &mockResettable{}
diff --git a/pkg/core/scheduler_test.go b/pkg/core/scheduler_test.go
index e2f7cf3..9cd8b47 100644
--- a/pkg/core/scheduler_test.go
+++ b/pkg/core/scheduler_test.go
@@ -71,7 +71,7 @@ func TestScheduler_JobExecution(t *testing.T) {
 	cfg.Ticker.TelemetryLoop = config.Duration(10 * time.Millisecond) // Fast loop
 
 	mockSim := &mockSimClient{state: sim.StateActive}
-	sched := NewScheduler(cfg, mockSim, nil, &mockSchedNarrator{}, &mockSchedGeoProvider{})
+	sched := NewScheduler(cfg, mockSim, nil, &mockSchedGeoProvider{})
 
 	// job fired latch
 	var firedCount int32
@@ -181,7 +181,10 @@ func TestScheduler_SkipsTelemetryWhenInactive(t *testing.T) {
 
 	mockSim := &mockStatefulSimClient{state: sim.StateInactive}
 	sink := &mockSink{}
-	sched := NewScheduler(cfg, mockSim, sink, &mockSchedNarrator{}, &mockSchedGeoProvider{})
+	// Define simClient and geoProv for the NewScheduler call
+	simClient := mockSim
+	geoProv := &mockSchedGeoProvider{}
+	sched := NewScheduler(cfg, simClient, sink, geoProv)
 
 	ctx, cancel := context.WithCancel(context.Background())
 	defer cancel()
diff --git a/pkg/llm/failover/provider.go b/pkg/llm/failover/provider.go
index 2eda453..b17c479 100644
--- a/pkg/llm/failover/provider.go
+++ b/pkg/llm/failover/provider.go
@@ -175,9 +175,9 @@ func (f *Provider) execute(ctx context.Context, callName, prompt string, fn func
 		backoffKey := c.name + ":" + callName
 		f.mu.Lock()
 		bs, exists := f.backoffs[backoffKey]
-		if exists && bs.skippedRequests < bs.subsequentFailures {
+		if exists && bs.skippedRequests < bs.subsequentFailures*2 {
 			bs.skippedRequests++
-			slog.Debug("LLM Provider in backoff, skipping", "provider", c.name, "profile", callName, "skipped", bs.skippedRequests, "target", bs.subsequentFailures)
+			slog.Debug("LLM Provider in backoff, skipping", "provider", c.name, "profile", callName, "skipped", bs.skippedRequests, "target", bs.subsequentFailures*2)
 			f.mu.Unlock()
 			continue
 		}
diff --git a/pkg/llm/failover/provider_test.go b/pkg/llm/failover/provider_test.go
index 5e231e4..ce13126 100644
--- a/pkg/llm/failover/provider_test.go
+++ b/pkg/llm/failover/provider_test.go
@@ -359,20 +359,23 @@ func TestFailover_ProfileSparse(t *testing.T) {
 func TestFailover_SmartBackoff(t *testing.T) {
 	// P1 will fail twice with 429, then eventually succeed
 	// Sequence of calls we expect to P1:
-	// 1. Fail (sf=1, sr=0) -> Skip next
+	// 1. Fail (sf=1, sr=0) -> Skip next 2
 	// 2. [Skipped]
-	// 3. Fail (sf=2, sr=0) -> Skip next 2
-	// 4. [Skipped]
+	// 3. [Skipped]
+	// 4. Fail (sf=2, sr=0) -> Skip next 4
 	// 5. [Skipped]
-	// 6. Success -> Reset
+	// 6. [Skipped]
+	// 7. [Skipped]
+	// 8. [Skipped]
+	// 9. Success -> Reset
 	p1 := &mockProvider{
 		responses: []string{"", "", "p1_success"},
 		errors:    []error{fmt.Errorf("429"), fmt.Errorf("429"), nil},
 	}
 	// P2 will always succeed
 	p2 := &mockProvider{
-		responses: []string{"p2_1", "p2_2", "p2_3", "p2_4", "p2_5", "p2_6"},
-		errors:    []error{nil, nil, nil, nil, nil, nil},
+		responses: []string{"p2_1", "p2_2", "p2_3", "p2_4", "p2_5", "p2_6", "p2_7", "p2_8", "p2_9"},
+		errors:    []error{nil, nil, nil, nil, nil, nil, nil, nil, nil},
 	}
 
 	f, _ := New([]llm.Provider{p1, p2}, []string{"p1", "p2"}, []time.Duration{time.Second, time.Second}, "", true, nil)
@@ -383,7 +386,7 @@ func TestFailover_SmartBackoff(t *testing.T) {
 		t.Errorf("Call 1: expected p2_1, got %s", res)
 	}
 
-	// Call 2: P1 skipped (sr:0 < sf:1). P2 called. (P1 calls: 1, P2 calls: 2)
+	// Call 2: P1 skipped (sr:0 < sf:1*2). P2 called. (P1 calls: 1, P2 calls: 2)
 	res, _ = f.GenerateText(context.Background(), "narration", "p")
 	if res != "p2_2" {
 		t.Errorf("Call 2: expected p2_2, got %s", res)
@@ -392,42 +395,49 @@ func TestFailover_SmartBackoff(t *testing.T) {
 		t.Errorf("Call 2: expected p1 count 1 (skipped), got %d", p1.callCount)
 	}
 
-	// Call 3: P1 tried (sr:1 < sf:1 is false), fails. P2 called. (P1 calls: 2, P2 calls: 3)
-	// sf becomes 2, sr reset to 0.
+	// Call 3: P1 skipped (sr:1 < sf:1*2). P2 called. (P1 calls: 1, P2 calls: 3)
 	res, _ = f.GenerateText(context.Background(), "narration", "p")
 	if res != "p2_3" {
 		t.Errorf("Call 3: expected p2_3, got %s", res)
 	}
-	if p1.callCount != 2 {
-		t.Errorf("Call 3: expected p1 count 2, got %d", p1.callCount)
+	if p1.callCount != 1 {
+		t.Errorf("Call 3: expected p1 count 1 (skipped), got %d", p1.callCount)
 	}
 
-	// Call 4: P1 skipped (sr:0 < sf:2). P2 called. (P1 calls: 2, P2 calls: 4)
+	// Call 4: P1 tried (sr:2 < sf:1*2 false), fails. P2 called. (P1 calls: 2, P2 calls: 4)
+	// sf becomes 2, sr reset to 0.
 	res, _ = f.GenerateText(context.Background(), "narration", "p")
 	if res != "p2_4" {
 		t.Errorf("Call 4: expected p2_4, got %s", res)
 	}
+	if p1.callCount != 2 {
+		t.Errorf("Call 4: expected p1 count 2, got %d", p1.callCount)
+	}
 
-	// Call 5: P1 skipped (sr:1 < sf:2). P2 called. (P1 calls: 2, P2 calls: 5)
-	res, _ = f.GenerateText(context.Background(), "narration", "p")
-	if res != "p2_5" {
-		t.Errorf("Call 5: expected p2_5, got %s", res)
+	// Call 5-8: P1 skipped (sr:0-3 < sf:2*2). P2 called. (P1 calls: 2, P2 calls: 5-8)
+	for i := 5; i <= 8; i++ {
+		res, _ = f.GenerateText(context.Background(), "narration", "p")
+		expected := fmt.Sprintf("p2_%d", i)
+		if res != expected {
+			t.Errorf("Call %d: expected %s, got %s", i, expected, res)
+		}
+	}
+	if p1.callCount != 2 {
+		t.Errorf("After Call 8: expected p1 count 2, got %d", p1.callCount)
 	}
 
-	// Call 6: P1 tried (sr:2 < sf:2 false), succeeds. (P1 calls: 3, P2 calls: 5)
+	// Call 9: P1 tried (sr:4 < sf:2*2 false), succeeds. (P1 calls: 3, P2 calls: 8)
 	res, _ = f.GenerateText(context.Background(), "narration", "p")
 	if res != "p1_success" {
-		t.Errorf("Call 6: expected p1_success, got %s", res)
+		t.Errorf("Call 9: expected p1_success, got %s", res)
 	}
-	if p2.callCount != 5 {
-		t.Errorf("Call 6: expected p2 count 5, got %d", p2.callCount)
+	if p2.callCount != 8 {
+		t.Errorf("Call 9: expected p2 count 8, got %d", p2.callCount)
 	}
 
-	// Call 7: P1 tried immediately (reset).
+	// Call 10: P1 tried immediately (reset).
 	res, _ = f.GenerateText(context.Background(), "narration", "p")
-	// Since P1 is out of mocked responses, it might fail or we should add more.
-	// But we just want to see it was called.
 	if p1.callCount != 4 {
-		t.Errorf("Call 7: expected p1 count 4, got %d", p1.callCount)
+		t.Errorf("Call 10: expected p1 count 4, got %d", p1.callCount)
 	}
 }
diff --git a/pkg/narrator/service.go b/pkg/narrator/service.go
index 1be0fe6..08ae94a 100644
--- a/pkg/narrator/service.go
+++ b/pkg/narrator/service.go
@@ -48,8 +48,6 @@ type Service interface {
 	PlayNarrative(ctx context.Context, n *model.Narrative) error
 	// PlayEssay triggers a regional essay narration.
 	PlayEssay(ctx context.Context, tel *sim.Telemetry) bool
-	// PlayBorder triggers a border crossing announcement.
-	PlayBorder(ctx context.Context, from, to string, tel *sim.Telemetry) bool
 	// SkipCooldown forces the cooldown to expire immediately.
 	SkipCooldown()
 	// ShouldSkipCooldown returns true if the cooldown should be skipped.
@@ -237,14 +235,6 @@ func (s *StubService) PlayEssay(ctx context.Context, tel *sim.Telemetry) bool {
 	return true
 }
 
-// PlayBorder triggers a border crossing announcement (stub).
-func (s *StubService) PlayBorder(ctx context.Context, from, to string, tel *sim.Telemetry) bool {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	slog.Info("Narrator stub: border announcement requested", "from", from, "to", to)
-	return true
-}
-
 // SkipCooldown forces the cooldown to expire immediately (stub: sets flag).
 func (s *StubService) SkipCooldown() {
 	s.mu.Lock()
diff --git a/pkg/narrator/service_ai.go b/pkg/narrator/service_ai.go
index 6bff521..be3a140 100644
--- a/pkg/narrator/service_ai.go
+++ b/pkg/narrator/service_ai.go
@@ -6,7 +6,6 @@ import (
 	"sync"
 	"time"
 
-	"phileasgo/pkg/announcement"
 	"phileasgo/pkg/audio"
 	"phileasgo/pkg/config"
 	"phileasgo/pkg/llm"
@@ -103,9 +102,7 @@ type AIService struct {
 	pendingManualStrategy string
 
 	// Infrastructure
-	legacyAnnouncements *AnnouncementManager // Legacy
-	announcements       *announcement.Manager
-	promptAssembler     *prompt.Assembler
+	promptAssembler *prompt.Assembler
 
 	// Replay State
 	lastPOI        *model.POI
@@ -180,15 +177,6 @@ func NewAIService(
 	// Initial default window
 	s.sim.SetPredictionWindow(60 * time.Second)
 
-	// Initialize Announcement Manager
-	s.legacyAnnouncements = NewAnnouncementManager(s)
-	s.announcements = announcement.NewManager(s)
-
-	// Register Announcements
-	s.announcements.Register(announcement.NewLetsgo(s))
-	s.announcements.Register(announcement.NewBriefing(s))
-	s.announcements.Register(announcement.NewDebriefing(s))
-
 	s.promptAssembler = prompt.NewAssembler(
 		cfg,
 		st,
@@ -316,22 +304,6 @@ func (s *AIService) persistSession(lat, lon float64) {
 // Heartbeat drives periodic tasks like announcements.
 func (s *AIService) Heartbeat(ctx context.Context, tel *sim.Telemetry) {
 	s.checkSessionPersistence(ctx, tel)
-
-	s.mu.RLock()
-	ann := s.legacyAnnouncements
-	s.mu.RUnlock()
-
-	if ann != nil {
-		ann.Tick(ctx, tel)
-	}
-
-	s.mu.RLock()
-	ann2 := s.announcements
-	s.mu.RUnlock()
-
-	if ann2 != nil {
-		ann2.Tick(ctx, tel)
-	}
 }
 
 // LLMProvider returns the internal LLM provider.
@@ -374,6 +346,13 @@ func (s *AIService) AssembleGeneric(ctx context.Context, t *sim.Telemetry) promp
 	return s.promptAssembler.ForGeneric(ctx, t, s.getSessionState())
 }
 
+func (s *AIService) GetBorderConfig() (enabled bool, cooldownAny, cooldownRepeat time.Duration) {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+	b := s.cfg.Narrator.Border
+	return b.Enabled, time.Duration(b.CooldownAny), time.Duration(b.CooldownRepeat)
+}
+
 func (s *AIService) NewContext() map[string]any {
 	s.initAssembler()
 	return map[string]any(s.promptAssembler.NewPromptData(s.getSessionState()))
diff --git a/pkg/narrator/service_ai_border.go b/pkg/narrator/service_ai_border.go
deleted file mode 100644
index 0b1a8d3..0000000
--- a/pkg/narrator/service_ai_border.go
+++ /dev/null
@@ -1,56 +0,0 @@
-package narrator
-
-import (
-	"context"
-	"log/slog"
-	"time"
-
-	"phileasgo/pkg/model"
-	"phileasgo/pkg/narrator/generation"
-	"phileasgo/pkg/sim"
-)
-
-// PlayBorder triggers a border crossing announcement.
-func (s *AIService) PlayBorder(ctx context.Context, from, to string, tel *sim.Telemetry) bool {
-	s.initAssembler()
-	s.mu.RLock()
-	// enabled := s.cfg.Narrator.Border.Enabled // TODO: Add to config if needed, default true for now
-	enabled := true
-	s.mu.RUnlock()
-
-	if !enabled {
-		return false
-	}
-
-	// Pause Respect
-	if s.audio != nil && s.audio.IsUserPaused() {
-		return false
-	}
-
-	// Queue Constraints
-	if !s.canEnqueuePlayback("border", true) {
-		slog.Info("Narrator: Border announcement skipped (queue constraints)")
-		return false
-	}
-
-	// Sync Checks (Wait for priority jobs)
-	if s.HasPendingGeneration() {
-		slog.Info("Narrator: Border announcement skipped (priority jobs pending)")
-		return false
-	}
-
-	slog.Info("Narrator: Border announcement requested", "from", from, "to", to)
-
-	// Enqueue for Generation (High Priority)
-	s.enqueueGeneration(&generation.Job{
-		Type:      model.NarrativeTypeBorder,
-		From:      from,
-		To:        to,
-		Manual:    true,
-		CreatedAt: time.Now(),
-		Telemetry: tel,
-	})
-	go s.ProcessGenerationQueue(context.Background())
-
-	return true
-}
diff --git a/pkg/narrator/service_ai_border_test.go b/pkg/narrator/service_ai_border_test.go
deleted file mode 100644
index 5b140a6..0000000
--- a/pkg/narrator/service_ai_border_test.go
+++ /dev/null
@@ -1,101 +0,0 @@
-package narrator
-
-import (
-	"context"
-	"os"
-	"path/filepath"
-	"strings"
-	"testing"
-	"time"
-
-	"phileasgo/pkg/config"
-	"phileasgo/pkg/llm/prompts"
-	"phileasgo/pkg/model"
-	"phileasgo/pkg/narrator/generation"
-	"phileasgo/pkg/sim"
-)
-
-func TestAIService_PlayBorder(t *testing.T) {
-	tempDir := t.TempDir()
-	_ = os.MkdirAll(filepath.Join(tempDir, "narrator"), 0o755)
-	_ = os.WriteFile(filepath.Join(tempDir, "narrator", "border.tmpl"), []byte("From {{.From}} to {{.To}} Summary: {{.TripSummary}} TTS: {{.TTSInstructions}}"), 0o644)
-	_ = os.MkdirAll(filepath.Join(tempDir, "common"), 0o755)
-	_ = os.MkdirAll(filepath.Join(tempDir, "tts"), 0o755)
-	_ = os.WriteFile(filepath.Join(tempDir, "tts", "edge-tts.tmpl"), []byte("TTS Info"), 0o644)
-	pm, _ := prompts.NewManager(tempDir)
-
-	cfg := &config.Config{}
-	mockLLM := &MockLLM{Response: "Border Script"}
-	mockTTS := &MockTTS{Format: "mp3"}
-	mockAudio := &MockAudio{}
-	mockPOI := &MockPOIProvider{
-		GetPOIFunc: func(ctx context.Context, qid string) (*model.POI, error) {
-			return &model.POI{WikidataID: qid, NameEn: "Test"}, nil
-		},
-	}
-	mockGeo := &MockGeo{Country: "US", City: "MockCity"}
-	mockSim := &MockSim{}
-	mockStore := &MockStore{}
-	mockWiki := &MockWikipedia{}
-	mockBeacon := &MockBeacon{}
-
-	var capturedPrompt string
-	mockLLM.GenerateTextFunc = func(ctx context.Context, name, prompt string) (string, error) {
-		capturedPrompt = prompt
-		return "Border Script", nil
-	}
-
-	svc := NewAIService(cfg, mockLLM, mockTTS, pm, mockAudio, mockPOI, mockBeacon, mockGeo, mockSim, mockStore, mockWiki, nil, nil, nil, nil, nil, nil)
-	svc.session().SetTripSummary("Recent history")
-	svc.Start()
-
-	// 1. Success Case
-	tel := &sim.Telemetry{Latitude: 10, Longitude: 20}
-	ok := svc.PlayBorder(context.Background(), "France", "Germany", tel)
-	if !ok {
-		t.Fatal("PlayBorder returned false, expected true")
-	}
-
-	// Trigger Generation
-	svc.ProcessGenerationQueue(context.Background())
-	time.Sleep(100 * time.Millisecond)
-
-	if svc.NarratedCount() != 1 {
-		t.Errorf("Expected 1 narrated border, got %d", svc.NarratedCount())
-	}
-
-	if !strings.Contains(capturedPrompt, "Summary: Recent history") {
-		t.Errorf("Expected prompt to contain TripSummary, got: %s", capturedPrompt)
-	}
-	if !strings.Contains(capturedPrompt, "TTS: TTS Info") {
-		t.Errorf("Expected prompt to contain TTSInstructions, got: %s", capturedPrompt)
-	}
-
-	// 2. Queue Constraint (Busy)
-	// Simulate busy by filling playback queue
-	svc.mu.Lock()
-	svc.playbackQ.Clear()
-	svc.playbackQ.Enqueue(&model.Narrative{Type: model.NarrativeTypeBorder, Manual: true}, false)
-	svc.playbackQ.Enqueue(&model.Narrative{Type: model.NarrativeTypeBorder, Manual: true}, false)
-	svc.playbackQ.Enqueue(&model.Narrative{Type: model.NarrativeTypeBorder, Manual: true}, false)
-	svc.playbackQ.Enqueue(&model.Narrative{Type: model.NarrativeTypeBorder, Manual: true}, false)
-	svc.playbackQ.Enqueue(&model.Narrative{Type: model.NarrativeTypeBorder, Manual: true}, false)
-	svc.mu.Unlock()
-
-	ok = svc.PlayBorder(context.Background(), "A", "B", tel)
-	if ok {
-		t.Error("PlayBorder should have failed due to queue limits")
-	}
-
-	// 3. Pending Generation
-	svc.mu.Lock()
-	svc.playbackQ.Clear()
-	svc.genQ.Clear()
-	svc.genQ.Enqueue(&generation.Job{Type: model.NarrativeTypePOI})
-	svc.mu.Unlock()
-
-	ok = svc.PlayBorder(context.Background(), "A", "B", tel)
-	if ok {
-		t.Error("PlayBorder should have failed due to pending generation")
-	}
-}
diff --git a/pkg/narrator/service_ai_queue.go b/pkg/narrator/service_ai_queue.go
index 34f824b..ec0b8cd 100644
--- a/pkg/narrator/service_ai_queue.go
+++ b/pkg/narrator/service_ai_queue.go
@@ -120,8 +120,6 @@ func (s *AIService) ProcessGenerationQueue(ctx context.Context) {
 			req = s.handlePOIJob(genCtx, job)
 		case model.NarrativeTypeScreenshot:
 			req = s.handleScreenshotJob(genCtx, job)
-		case model.NarrativeTypeBorder:
-			req = s.handleBorderJob(genCtx, job)
 		default:
 			req = s.handleAnnouncementJob(genCtx, job)
 		}
@@ -315,29 +313,6 @@ func (s *AIService) handleScreenshotJob(ctx context.Context, job *generation.Job
 	}
 }
 
-func (s *AIService) handleBorderJob(ctx context.Context, job *generation.Job) *GenerationRequest {
-	s.initAssembler()
-	data := s.promptAssembler.NewPromptData(s.getSessionState())
-	data["From"] = job.From
-	data["To"] = job.To
-	data["MaxWords"] = 30                                                                                                   // Short statement
-	data["TTSInstructions"] = s.promptAssembler.ForPOI(ctx, nil, job.Telemetry, "", s.getSessionState())["TTSInstructions"] // Hacky but works to get TTS instructions
-	prompt, err := s.prompts.Render("narrator/border.tmpl", data)
-	if err != nil {
-		slog.Error("Narrator: Failed to render border prompt", "error", err)
-		return nil
-	}
-	return &GenerationRequest{
-		Type:          model.NarrativeTypeBorder,
-		Prompt:        prompt,
-		Title:         "Border Crossing",
-		SafeID:        "border_" + time.Now().Format("150405"),
-		MaxWords:      data["MaxWords"].(int),
-		Manual:        true,
-		SkipBusyCheck: true,
-	}
-}
-
 func (s *AIService) handleAnnouncementJob(ctx context.Context, job *generation.Job) *GenerationRequest {
 	if job.Announcement == nil {
 		slog.Warn("Narrator: ProcessPriorityQueue received unsupported job type", "type", job.Type)
@@ -367,7 +342,8 @@ func (s *AIService) handleAnnouncementJob(ctx context.Context, job *generation.J
 		MaxWords:      300,
 		Manual:        true, // Announcements are treated with same priority as manual
 		SkipBusyCheck: true,
-		ThumbnailURL:  job.Announcement.ImagePath(),
+		ThumbnailURL:  job.Announcement.ImagePath(), // Falls back to empty if none
+		ImagePath:     job.Announcement.ImagePath(), // Explicit for screenshot analysis
 		POI:           job.Announcement.POI(),
 	}
 }
